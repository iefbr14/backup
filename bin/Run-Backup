#!/usr/bin/perl -w

=head1 NAME

=head1 USAGE

=head1 REQUIRED ARGUMENTS

=head1 OPTION

=head1 DESCRIPTION

=head1 DIAGNOSTICS

=head1 EXIT STATUS

=head1 CONFIGURATION

=head1 DEPENDENCIES

=head1 INCOMPATIBILITIES

=head1 BUGS AND LIMITATIONS

=head1 AUTHOR

=head1 LICENSE COPYRIGHT

=cut

#
# $Header: $
#

use strict;
use warnings;
use Getopt::Std;

use POSIX qw(strftime);
use File::Glob ':glob';
use File::Path qw(make_path);

sub usage {
	die <<"EOF";
Usage: $0 [options...] [args]...
   --
Options:
   -x     -- turn Debugging on.
   -d     -- dry run (don't do backups).
   -c     -- clean up archives

   -A     -- all sites auto
   -R     -- rotate logs
EOF
}

my(%Opt);
getopts('xdCAR', \%Opt) || usage;

my($Debug)   = $Opt{x} || 0;
my($Dryrun)  = $Opt{d} || 0;
my($Cleanup) = $Opt{c} || 0;

my($Allsite) = $Opt{A} || 0;
my($Rotate ) = $Opt{R} || 0;

if ( ! -d 'bin' ) {
	die "Please run in your backup directory."
}

my(@now) = localtime;
my($DOW) = strftime("%a", @now);

print strftime("$DOW Backup: %Y-%m-%d.%T\n", @now);

make_path('Logs', 'Old', 'Run', { verbose => 1, mode=> 0644 });

if ($Rotate) {
	for my $log (<Logs/$DOW.*>) {
		my($to) = $log; $to =~ s/^Logs/Old/;

		if ($Dryrun) {
			print "# LOG: $log => $to\n";
		} else {
			print "+ mv LOG $log => $to\n";

			rename($log, $to) or warn "Can't rename $log => $to\n";
		}
	}
}

if ($Allsite && @ARGV == 0) {
	$Cleanup = ($DOW eq 'Sun');
	@ARGV = <*.*.*>;
}

if ($Cleanup) {
	for my $HOST (@ARGV) {
		clean_up($HOST);
	}
}

for my $HOST (@ARGV) {
	backup($HOST);
}

print strftime("$DOW Done: %Y-%m-%d.%T\n", localtime);


sub backup {
	my($machine) = @_;

	unless (open(LOG, ">> Logs/$DOW.$machine")) {
		warn "Can't log to: Logs/$DOW.$machine ($!)\n";
		return;
	}
		
	plog("==============[ $machine ]==============");

	if (! -d $machine) {
		perr("Back-up $machine not setup, skipping");
		return;
	}

	if ($Allsite && -M "$machine/rdiff-backup-data" < 0.4) {
		perr("Back-up $machine too soon ago, skipping");
		return;
	}


	plog(strftime("Start: $machine %Y-%m-%d.%T", localtime));

	unless (open(I, "Include/$machine")) {
		perr("Can't open include list: Include/$machine ($!)");
		return;
	}
	unless (open(O, "> Run/$machine")) {
		perr("Can't open include list: Run/$machine ($!)");
		return;
	}
	
	my(@FORCE) = ();

	if ( ! -d "$machine/rdiff-backup-data" ) {
		@FORCE = ('--force');
	}
	if ( -f "Include/$machine.force" ) {
		@FORCE = ('--force');
	}

	umask(000);

	my(%mp);

	my($mode, $mp);
	while (<I>) {
		next if /^\s*$/;
		next if /^\s*#/;


		chomp;
		($mode, $mp) = split(' ', $_);

		if ($mode eq '+') {
			print O "+ $mp\n";
		} else {
			print O "$mp\n";
		}

		$mp{$mp} = [ $mode ];

		print "# B $mode $mp\n" if $Debug;
	}
	close(I);


	unless (open(I, "ssh root\@$machine 'cat /proc/mounts'|")) {
		perr("Can't ssh $machine to get mounts");
	}

	while (<I>) {
		chomp;
		my ($fs, $mp, $type, @rest) = split(' ');

		my($guess) = guess_mode($type);

		print "# L $guess $mp # $type\n" if $Debug;

		next if $mp eq '/';

		# if we already have this one.
		next if defined $mp{$mp}[0];

		perr("Mount point $mp => $fs => $type @rest new");
		plog("Logically added: - $mp");
		$mode = '-';
		print O "$mp\n";
	}

	if ($mode ne '-') {
		perr("Last item in Include/$machine is not an exclude (rdiff-bug)");
		print O "/tmp/rdiff-bug-needs-excludes-as-last\n";
	}

#	print O "/\n";
	close(O);

	run('rdiff-backup', @FORCE, 
		'--exclude-sockets',
		'--exclude-other-filesystems',
		'--exclude-globbing-filelist', "Run/$machine",
		'--print-statistics',
		$machine."::/", $machine
	);
		
	if (@FORCE) {
		if ($Dryrun) {
			plog("# rm Include/$machine.force");
		} else {
			unlink("Include/$machine.force");
		}
	}

	plog(strftime("Finish: $machine %Y-%m-%d.%T", localtime));
}

sub guess_mode {
	my($type) = @_;

	# synthetic
	return '-' if $type eq 'proc';
	return '-' if $type eq 'sysfs';
	return '-' if $type eq 'tmpfs';
	return '-' if $type eq 'devtmpfs';
	return '-' if $type eq 'devpts';
	return '-' if $type eq 'usbfs';
	return '-' if $type eq 'binfmt_misc';
	return '-' if $type eq 'rpc_pipefs';
	return '-' if $type eq 'fusectl';
	return '-' if $type eq 'debugfs';
	return '-' if $type eq 'securityfs';
	return '-' if $type eq 'selinuxfs';
	return '-' if $type eq 'autofs';
	return '-' if $type eq 'fuse.gvfs-fuse-daemon';

	# remote
	return '-' if $type eq 'nfs';
	return '-' if $type eq 'nfsd';
	return '-' if $type eq 'nfs4';

	return '*' if $type eq 'rootfs';

	return '+' if $type eq 'ext2';
	return '+' if $type eq 'ext3';
	return '+' if $type eq 'ext4';

	perr("Unknown type: $type");
	return '-';
}

sub clean_up {
	my($machine) = @_;

	open(LOG, ">> $DOW=Clean-Up.log");

	### BUG move cleanup code here.
	run("bin/clean-up $machine");

	close(LOG);
}

sub run {
	my($cmd) = join(' ', @_);

	plog("+ $cmd");

	unshift(@_, 'bin/guard-cmd', '-w', '-l', 'backup');


	if ($Dryrun) {
		plog("## $cmd");
		return;
	}

	print "++ $cmd\n" if $Debug;

	unless (open(CMD, "$cmd 2>&1 |")) {
		perr("Can't run $cmd ($!)");
		return;
	}
	while (<CMD>) {
		chomp;
		plog($_);
	}
	close(CMD);
	return if $? == 0;

	perr("Command failed: rc = $?");
}

sub plog {
	print LOG @_, "\n";
	print @_, "\n";
}

sub perr {
	print LOG    @_, "\n";
	print STDERR @_, "\n";
}
